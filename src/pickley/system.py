"""
Functionality for the whole app, easily importable via one name
"""

import inspect
import logging
import os
import re
import sys

import runez
from click import UsageError

LOG = logging.getLogger(__name__)
PICKLEY = "pickley"

WRAPPER_MARK = "# Wrapper generated by https://pypi.org/project/pickley/"

SETTINGS = None
DESIRED_PYTHON = None  # type: str | None # Desired python installation (if explicitly stated via CLI flags)

LATEST_CHANNEL = "latest"
VENV_PACKAGER = "venv"
DEFAULT_DELIVERY = "symlink"
INVOKER = "invoker"

RE_PYTHON_LOOSE = re.compile(r"(py(thon ?)?)?([0-9])?\.?([0-9])?\.?[0-9]*", re.IGNORECASE)
RE_PYTHON_STRICT = re.compile(r"(python([0-9]\.[0-9])|([0-9]\.[0-9])\.?[0-9]*)")

RE_PYPI_ACCEPTABLE = re.compile(r"^[a-z0-9][a-z0-9_.-]*$", re.IGNORECASE)
RE_PYPI_DASHED_NAME = re.compile(r"^[a-z0-9-]+$")

PICKLEY_PROGRAM_PATH = runez.resolved_path(sys.argv[0])


def setup_audit_log():
    """Setup audit.log, if not already setup"""
    if not runez.log.file_handler and not runez.DRYRUN:
        runez.log.setup(
            file_format="%(asctime)s %(timezone)s [%(process)d] %(context)s%(levelname)s - %(message)s",
            file_level=logging.DEBUG,
            file_location=SETTINGS.meta.full_path("audit.log"),
            greetings=":: {argv}",
            rotate="size:500k",
            rotate_count=1,
        )


def inform(message):
    """
    Args:
        message (str): Message to print and log at level INFO
    """
    print(message)
    logger = logging.getLogger(inspect.currentframe().f_back.f_globals["__name__"])
    logger.info(message)


def despecced(text):
    """
    :param str text: Text of form <name>==<version>, or just <name>
    :return str, str|None: Name and version
    """
    version = None
    if text and "==" in text:
        i = text.strip().index("==")
        version = text[i + 2:]
        text = text[:i]
    return text, version


class PackageSpec(object):
    """
    Deal with confusion around python package naming:
    - accepted chars are: alpha numeric, or "-" and "."
    - pypi assumes names are lowercased and dash-separated
    - wheel transforms dashes to underscores
    """

    def __init__(self, text):
        """
        Args:
            text (str): Given package name, with optional version spec
        """
        self.original, self.version = despecced(text)
        if not text or not RE_PYPI_ACCEPTABLE.match(self.original):
            raise UsageError("'%s' is not a valid pypi package name" % self.original)
        self.dashed = self.original.lower().replace("_", "-").replace(".", "-")
        self.pythonified = self.original.replace("-", "_").replace(".", "_")

    def __str__(self):
        return self.specced

    @property
    def specced(self):
        return "%s==%s" % (self.dashed, self.version) if self.version else self.dashed

    @property
    def multi_named(self):
        return self.dashed != self.pythonified

    @classmethod
    def is_valid(cls, text):
        name, _ = despecced(text)
        return bool(name and RE_PYPI_ACCEPTABLE.match(name))

    def _version_part(self, filename):
        if filename:
            filename = filename.lower()
            n = len(self.pythonified) + 1
            if filename.startswith("%s-" % self.pythonified):
                return filename[n:]
            if filename.startswith("%s-" % self.pythonified.lower()):
                return filename[n:]
            n = len(self.dashed) + 1
            if filename.startswith("%s-" % self.dashed):
                return filename[n:]
            n = len(self.original) + 1
            if filename.startswith("%s-" % self.original.lower()):
                return filename[n:]

    def version_part(self, filename):
        """
        Args:
            filename (str): Filename to examine

        Returns:
            (str | None): Version extracted from `filename`, if applicable to current package spec
        """
        vp = self._version_part(filename)
        if vp and vp[0].isdigit():
            return vp


def resolved_package_specs(names, auto_complete=False):
    """
    :param list|tuple|str|None names: Names (possibly bundles) to resolve
    :param bool auto_complete: If True, and no 'names' provided, return list of currently installed packages
    :return list[PackageSpec]: Resolved specs
    """
    result = []
    if names:
        if hasattr(names, "split"):
            names = names.split()
        for name in names:
            if name.startswith("bundle:"):
                bundle = SETTINGS.get_value("bundle.%s" % name[7:])
                if bundle:
                    result.extend(bundle)
                    continue
            result.append(name)

    elif auto_complete and os.path.isdir(SETTINGS.meta.path):
        for fname in os.listdir(SETTINGS.meta.path):
            if PackageSpec.is_valid(fname):
                fpath = os.path.join(SETTINGS.meta.path, fname)
                if os.path.isdir(fpath):
                    if os.path.exists(os.path.join(fpath, ".current.json")):
                        result.append(fname)

    return [PackageSpec(name) for name in runez.flattened(result, split=runez.UNIQUE)]


def is_universal(wheels_folder):
    """
    :param str wheels_folder: Path to folder where wheels reside
    :return bool: True if all wheels in the folder are universal
    """
    if wheels_folder and os.path.isdir(wheels_folder):
        return not any(n.endswith(".whl") and not n.endswith("-py2.py3-none-any.whl") for n in os.listdir(wheels_folder))


def run_python(*args, **kwargs):
    """Invoke targetted python interpreter with given args"""
    package_spec = kwargs.pop("package_spec", None)
    python = target_python(package_spec=package_spec)
    return runez.run(python.executable, *args, **kwargs)


def parent_python():
    prefix = getattr(sys, "real_prefix", None)
    if prefix:
        path = os.path.join(prefix, "bin", "python")
        if runez.is_executable(path):
            return path


def target_python(desired=None, package_spec=None, fatal=True):
    """
    :param str|None desired: Desired python (overrides anything else configured)
    :param PackageSpec|None package_spec: Target pypi package
    :param bool|None fatal: If True, abort execution if python invalid
    :return PythonInstallation: Python installation to use
    """
    if not desired:
        desired = DESIRED_PYTHON or SETTINGS.resolved_value("python", package_spec=package_spec) or INVOKER
    python = PythonInstallation(desired)
    if not python.is_valid:
        return runez.abort(python.problem, fatal=(fatal, python))

    return python


class PythonInstallation(object):

    text = None  # type: str # Given description or path
    executable = None  # type: str # Full path to python executable
    major = None  # type: str # Major version
    minor = None  # type: str # Minor version

    def __init__(self, text):
        """
        :param str text: Python, of the form: python, or python3.6, or py36, or full path to exe
        """
        self.text = text
        if text == INVOKER:
            text = parent_python() or sys.executable
        if os.path.isabs(text):
            self._set_executable(text)
            return
        m = RE_PYTHON_LOOSE.match(text)
        if m:
            self.major = m.group(3)
            self.minor = m.group(4)
            self.resolve_executable()

    def _set_executable(self, path):
        path = runez.resolved_path(path)
        if runez.is_executable(path):
            self.executable = path
            if not self.major or not self.minor:
                output = runez.run(self.executable, "--version", dryrun=False, fatal=None, include_error=True, logger=None)
                if output:
                    m = RE_PYTHON_LOOSE.match(output)
                    if m:
                        self.major = m.group(3)
                        self.minor = m.group(4)

    def resolve_executable(self):
        """Resolve executable from given major/minor"""
        self._set_executable(self._resolve_from_configured(SETTINGS.get_value("python_installs")))
        if not self.executable:
            self._set_executable(runez.which(self.program_name, ignore_own_venv=True))

    def _resolve_from_configured(self, folder):
        """
        Resolve python executable from a configured folder
        This aims to support pyenv like installations, as well as /usr/bin-like ones
        """
        folder = runez.resolved_path(folder)
        if not folder or not self.major or not os.path.isdir(folder):
            return None

        timestamp = None
        result = None
        interesting = [self.program_name, "%s.%s" % (self.major, self.minor or "")]
        for fname in os.listdir(folder):
            m = RE_PYTHON_STRICT.match(fname)
            if not m:
                continue
            m = m.group(2) or m.group(3)
            if not m or not any(m.startswith(x) for x in interesting):
                continue
            ts = os.path.getmtime(os.path.join(folder, fname))
            if timestamp is None or timestamp < ts:
                timestamp = ts
                result = fname

        return result and self._first_executable(
            os.path.join(folder, result, "bin", "python"),
            os.path.join(folder, result),
        )

    def _first_executable(self, *paths):
        for path in paths:
            if runez.is_executable(path):
                return path
        return None

    def __repr__(self):
        if self.is_valid:
            return "%s [%s.%s]" % (self.executable, self.major, self.minor)
        return self.program_name

    def shebang(self, universal=False):
        """
        :param bool universal: True if produced package is universal
        :return str: Shebang to use
        """
        if DESIRED_PYTHON and os.path.isabs(DESIRED_PYTHON):
            return DESIRED_PYTHON
        if universal:
            return "/usr/bin/env python"
        if os.path.isabs(self.text):
            return self.executable
        return "/usr/bin/env %s" % self.program_name

    @property
    def problem(self):
        if not self.major or not self.minor:
            if self.major:
                return "'%s' is not a valid python installation" % (self.executable or self.program_name)
            return "No python installation '%s' found" % self.text
        if not self.executable:
            return "%s is not installed" % self.program_name
        return None

    @property
    def is_valid(self):
        return self.problem is None

    @property
    def short_name(self):
        return "py%s%s" % (self.major, self.minor)

    @property
    def program_name(self):
        if self.major and self.minor:
            return "python%s.%s" % (self.major, self.minor)
        elif self.major:
            return "python%s" % self.major
        elif self.text and self.text.startswith("python"):
            return self.text
        return "python '%s'" % self.text
